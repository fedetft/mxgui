/***************************************************************************
 *   Copyright (C) 2011 by Terraneo Federico                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   As a special exception, if other files instantiate templates or use   *
 *   macros or inline functions from this file, or you compile this file   *
 *   and link it with other works to produce a work based on this file,    *
 *   this file does not by itself cause the resulting work to be covered   *
 *   by the GNU General Public License. However the source code for this   *
 *   file must still be made available in accordance with the GNU General  *
 *   Public License. This exception does not invalidate any other reasons  *
 *   why a work based on this file might be covered by the GNU General     *
 *   Public License.                                                       *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, see <http://www.gnu.org/licenses/>   *
 ***************************************************************************/

#include <algorithm>
#include "triangle_fsm.h"

using namespace std;
using namespace mxgui;

TriangleFSM::TriangleFSM() {}

TriangleFSM::TriangleFSM(const short* idx, const short *vl, Color color)
        : color(color)
{
    short x[3]={ vl[3*idx[0]],   vl[3*idx[1]],   vl[3*idx[2]]   };
    short y[3]={ vl[3*idx[0]+1], vl[3*idx[1]+1], vl[3*idx[2]+1] };
    z=(vl[3*idx[0]+2]+vl[3*idx[1]+2]+vl[3*idx[2]+2])/3; //Using averaged z

    //Check if the vertices are aligned, in this case it's not a triangle but
    //an horizontal or vertical line, that is, an invalid triangle
    if(x[0]==x[1] && x[1]==x[2]) return;
    if(y[0]==y[1] && y[1]==y[2]) return;

    //Sorting the triangle's vertices by y coordinate, unrolled
    if(y[0]>y[1]) { swap(y[0],y[1]); swap(x[0],x[1]); }
    if(y[1]>y[2]) { swap(y[1],y[2]); swap(x[1],x[2]); }
    if(y[0]>y[1]) { swap(y[0],y[1]); swap(x[0],x[1]); }

    if(y[0]==y[1])
    {
        //  ----  : Triangle with flat top
        //  \  /  :
        //   \/   :
        leftEdge= BresenhamFSM(Point(min(x[0],x[1]),y[0]),Point(x[2],y[2]));
        rightEdge=BresenhamFSM(Point(max(x[0],x[1]),y[0]),Point(x[2],y[2]));
    } else if(y[1]==y[2])
    {
        //   /\   :
        //  /  \  :
        //  ----  : Triangle with flat bottom
        leftEdge= BresenhamFSM(Point(min(x[1],x[2]),y[1]),Point(x[0],y[0]));
        rightEdge=BresenhamFSM(Point(max(x[1],x[2]),y[1]),Point(x[0],y[0]));
    } else {
        //Compute intersection between line generated by Point(x[0],y[0]),
        //Point(x[2],y[2]) and horizontal line y=y[1]
        short xl=x[0],yl=y[0],xh=x[2],yh=y[2];
        short xm,ym;
        for(;;)
        {
            xm=(xl+xh)/2;
            ym=(yl+yh)/2;
            if(ym==y[1] || ym==y[1]+1) break;
            if(ym<y[1])
            {
                xl=xm;
                yl=ym;
            } else {
                xh=xm;
                yh=ym;
            }
        }
        
        //Not a triangle, vertices aligned in an oblique line
        if(xm==x[1]) return;

        this->mid=Point(x[1],y[1]);
        this->last=Point(x[2],y[2]);

        if(x[1]>xm)
        {
            //      /\  :
            //     /  \ :
            //    /   / :
            //   /  /   :
            //  / /     :
            //  '       : Triangle with right middlepoint
            leftEdge= BresenhamFSM(Point(x[0],y[0]),last);
            rightEdge=BresenhamFSM(Point(x[0],y[0]),mid);
        } else {
            //  /\      :
            // /  \     :
            // \   \    :
            //   \  \   :
            //     \ \  :
            //       `  : Triangle with left middlepoint
            leftEdge= BresenhamFSM(Point(x[0],y[0]),mid);
            rightEdge=BresenhamFSM(Point(x[0],y[0]),last);
        }
    }
    leftEdge.getLinePoints(); //Advance both as first scanline not drawn
    rightEdge.getLinePoints();
}

bool TriangleFSM::drawScanLine(mxgui::Color scanLine[])
{
    short left=leftEdge.getLeftmost();
    short right=rightEdge.getRightmost();
    if(left<0 && right<0) return false;
    if(left<0)
    {
        leftEdge=BresenhamFSM(mid,last);
        leftEdge.getLeftmost(); //Advance the bresenham fsm
        left=leftEdge.getLeftmost();
    }
    if(right<0)
    {
        rightEdge=BresenhamFSM(mid,last);
        rightEdge.getRightmost(); //Advance the bresenham fsm
        right=rightEdge.getRightmost();
    }
    for(int i=left;i<right;i++) scanLine[i]=color;
    return true;
}

bool TriangleFSM::advanceWithoutDrawing()
{
    short left=leftEdge.getLeftmost();
    short right=rightEdge.getRightmost();
    if(left<0 && right<0) return false;
    if(left<0)
    {
        leftEdge=BresenhamFSM(mid,last);
        leftEdge.getLeftmost(); //Advance the bresenham fsm
        left=leftEdge.getLeftmost();
    }
    if(right<0)
    {
        rightEdge=BresenhamFSM(mid,last);
        rightEdge.getRightmost(); //Advance the bresenham fsm
        right=rightEdge.getRightmost();
    }
    return true;
}

/*
// Testcase code for TriangleFSM class

#include <cstring>
#include <unistd.h>
#include "mxgui/entry.h"
#include "mxgui/display.h"
#include "mxgui/misc_inst.h"
#include "math_helpers.h"

using namespace mxgui;

ENTRY()
{
    static const short indices[]={0,1,2,3}; //Triangle strip style
    static const float vertices[]=
    {
//         0.0f, 0.5f, 0.0f,
//        -0.5f, 0.0f, 0.0f,
//         0.5f, 0.0f, 0.0f,
//         0.0f,-0.5f, 0.0f
        -0.5f, 0.5f, 0.0f,
         0.0f, 0.0f, 0.0f,
         0.0f,-0.5f, 0.0f,
         0.5f, 0.5f, 0.0f
    };
    
    for(float angle=0.0f;;angle-=10*M_PI/180.0f)
    {
        Matrix3f rot=zrot(angle)*scale(100.0f);
        short xfmvertices[12];
        for(int i=0;i<4;i++)
        {
            Vector3f v=rot*Vector3f(vertices+3*i);
            short x=240/2+v.at(0);
            short y=320/2-v.at(1);
            short z=v.at(2);
            *(xfmvertices+3*i+0)=x;
            *(xfmvertices+3*i+1)=y;
            *(xfmvertices+3*i+2)=z;
        }
        {
            DrawingContext dc(DisplayManager::instance().getDisplay());
            dc.clear(black);
            short minya=min(xfmvertices[1],min(xfmvertices[4],xfmvertices[7]));
            short minyb=min(xfmvertices[4],min(xfmvertices[7],xfmvertices[10]));
            TriangleFSM tri1(indices,xfmvertices,red);
            TriangleFSM tri2(indices+1,xfmvertices,green);
            bool active1=false, active2=false;
            short miny=min(minya,minyb);
            Color *line=new Color[240];
            for(;;)
            {
                memset(line,0,240*sizeof(Color));
                if(!active1 && miny==minya) active1=true;
                if(!active2 && miny==minyb) active2=true;
                if(active1) if(tri1.drawScanLine(line)==false) active1=false;
                if(active2) if(tri2.drawScanLine(line)==false) active2=false;
                dc.scanLine(Point(0,++miny),line,240);
                if(!active1 && !active2 || miny>300) break;
            }
            delete[] line;
            dc.beginPixel();
            dc.setPixel(Point(xfmvertices[0],xfmvertices[1]),white);
            dc.setPixel(Point(xfmvertices[3],xfmvertices[4]),white);
            dc.setPixel(Point(xfmvertices[6],xfmvertices[7]),white);
            dc.setPixel(Point(xfmvertices[9],xfmvertices[10]),white);
        }
        usleep(1000000);
    }
}
*/
